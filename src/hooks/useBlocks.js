import { useState, useEffect } from 'react';
import { collection, onSnapshot } from 'firebase/firestore';
import { db } from '../services/firebase';
import blocosData from '../data/blocos.json';

const staticBlocks = Array.isArray(blocosData) ? blocosData : (blocosData?.default || []);

export const useBlocks = () => {
    const [blocks, setBlocks] = useState(staticBlocks);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        // If Firestore is not initialized (e.g. during build or error), fallback to static
        if (!db) {
            setLoading(false);
            return;
        }

        const unsubscribe = onSnapshot(
            collection(db, 'approved_blocks'),
            (snapshot) => {
                const dynamicBlocks = [];
                snapshot.forEach((doc) => {
                    dynamicBlocks.push({ id: doc.id, ...doc.data() });
                });

                // Merge: Dynamic blocks take precedence or properly deduplicate
                // For simplicty, we append dynamic blocks. 
                // ID collision strategy: If static has same ID, use dynamic? 
                // Assumes dynamic blocks have unique IDs generated by Firestore or explicit IDs.

                // Using a Map to deduplicate by ID if necessary, favoring dynamic
                const blockMap = new Map(staticBlocks.map(b => [b.id, b]));
                dynamicBlocks.forEach(b => blockMap.set(b.id, b));

                setBlocks(Array.from(blockMap.values()));
                setLoading(false);
            },
            (err) => {
                console.error("Error fetching dynamic blocks:", err);
                setError(err);
                // Fallback to static on error
                setLoading(false);
            }
        );

        return () => unsubscribe();
    }, []);

    return { blocks, loading, error };
};
